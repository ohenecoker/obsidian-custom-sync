/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  serverUrl: "https://jollofriceboy.com/api",
  username: "",
  token: "",
  vaultName: "",
  syncInterval: 5,
  // minutes
  lastSync: "",
  syncAllVaults: false,
  knownVaults: []
};
var ObsidianSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.isSyncing = false;
  }
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("sync", "Sync Vault", async (evt) => {
      await this.syncVault();
    });
    this.addCommand({
      id: "sync-vault",
      name: "Sync vault with server",
      callback: async () => {
        await this.syncVault();
      }
    });
    this.addCommand({
      id: "sync-all-vaults",
      name: "Sync all vaults with server",
      callback: async () => {
        await this.syncAllVaults();
      }
    });
    this.addSettingTab(new SyncSettingTab(this.app, this));
    if (this.settings.token && this.settings.syncInterval > 0) {
      this.startAutoSync();
    }
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (!this.isSyncing && file instanceof import_obsidian.TFile) {
          await this.queueFileForSync(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        if (!this.isSyncing && file instanceof import_obsidian.TFile) {
          await this.queueFileForDeletion(file);
        }
      })
    );
  }
  onunload() {
    if (this.syncInterval) {
      window.clearInterval(this.syncInterval);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  startAutoSync() {
    if (this.syncInterval) {
      window.clearInterval(this.syncInterval);
    }
    this.syncInterval = window.setInterval(async () => {
      await this.syncVault();
    }, this.settings.syncInterval * 60 * 1e3);
  }
  async login(username, password) {
    try {
      const response = await fetch(`${this.settings.serverUrl}/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ username, password })
      });
      if (!response.ok) {
        throw new Error("Login failed");
      }
      const data = await response.json();
      this.settings.token = data.token;
      this.settings.username = username;
      await this.saveSettings();
      return true;
    } catch (error) {
      console.error("Login error:", error);
      new import_obsidian.Notice("Login failed: " + error.message);
      return false;
    }
  }
  async registerUser(username, password) {
    try {
      const response = await fetch(`${this.settings.serverUrl}/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ username, password })
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || "Registration failed");
      }
      return await this.login(username, password);
    } catch (error) {
      console.error("Registration error:", error);
      new import_obsidian.Notice("Registration failed: " + error.message);
      return false;
    }
  }
  async syncVault() {
    if (this.isSyncing) {
      new import_obsidian.Notice("Sync already in progress");
      return;
    }
    if (!this.settings.token) {
      new import_obsidian.Notice("Please login first");
      return;
    }
    this.isSyncing = true;
    new import_obsidian.Notice("Starting sync...");
    try {
      await this.ensureVault();
      await this.pullChanges();
      await this.pushChanges();
      this.settings.lastSync = (/* @__PURE__ */ new Date()).toISOString();
      await this.saveSettings();
      new import_obsidian.Notice("Sync completed successfully");
    } catch (error) {
      console.error("Sync error:", error);
      new import_obsidian.Notice("Sync failed: " + error.message);
    } finally {
      this.isSyncing = false;
    }
  }
  async ensureVault() {
    const vaultName = this.settings.vaultName || this.app.vault.getName();
    const response = await fetch(`${this.settings.serverUrl}/vault`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ vaultName })
    });
    if (!response.ok) {
      throw new Error("Failed to create/access vault on server");
    }
    this.settings.vaultName = vaultName;
    await this.saveSettings();
  }
  async pullChanges() {
    const vaultName = this.settings.vaultName || this.app.vault.getName();
    const response = await fetch(`${this.settings.serverUrl}/sync/pull`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        vaultName,
        lastSync: this.settings.lastSync
      })
    });
    if (!response.ok) {
      throw new Error("Failed to pull changes from server");
    }
    const data = await response.json();
    const serverFiles = data.files;
    for (const serverFile of serverFiles) {
      const localFile = this.app.vault.getAbstractFileByPath(serverFile.path);
      if (serverFile.deleted) {
        if (localFile instanceof import_obsidian.TFile) {
          await this.app.vault.delete(localFile);
        }
      } else {
        if (localFile instanceof import_obsidian.TFile) {
          const localMtime = localFile.stat.mtime;
          if (serverFile.modified_time > localMtime) {
            await this.app.vault.modify(localFile, serverFile.content);
          }
        } else {
          const dir = serverFile.path.substring(0, serverFile.path.lastIndexOf("/"));
          if (dir) {
            await this.ensureDirectory(dir);
          }
          await this.app.vault.create(serverFile.path, serverFile.content);
        }
      }
    }
  }
  async pushChanges() {
    const vaultName = this.settings.vaultName || this.app.vault.getName();
    const files = this.app.vault.getMarkdownFiles();
    const filesToSync = [];
    for (const file of files) {
      const content = await this.app.vault.read(file);
      filesToSync.push({
        path: file.path,
        content,
        modifiedTime: file.stat.mtime,
        deleted: false
      });
    }
    if (filesToSync.length === 0) {
      return;
    }
    const response = await fetch(`${this.settings.serverUrl}/sync/push`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${this.settings.token}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        vaultName,
        files: filesToSync
      })
    });
    if (!response.ok) {
      throw new Error("Failed to push changes to server");
    }
  }
  async ensureDirectory(path) {
    const parts = path.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const folder = this.app.vault.getAbstractFileByPath(currentPath);
      if (!folder) {
        await this.app.vault.createFolder(currentPath);
      }
    }
  }
  async queueFileForSync(file) {
    console.log("File modified:", file.path);
  }
  async queueFileForDeletion(file) {
    console.log("File deleted:", file.path);
  }
  async syncAllVaults() {
    if (!this.settings.token) {
      new import_obsidian.Notice("Please login first");
      return;
    }
    new import_obsidian.Notice("Fetching all vaults from server...");
    try {
      const response = await fetch(`${this.settings.serverUrl}/vaults`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.token}`
        }
      });
      if (!response.ok) {
        throw new Error("Failed to fetch vault list");
      }
      const vaults = await response.json();
      this.settings.knownVaults = vaults.map((v) => v.name);
      await this.saveSettings();
      new import_obsidian.Notice(`Found ${vaults.length} vaults. Syncing all...`);
      const syncedVaultsFolder = "Synced Vaults";
      await this.ensureDirectory(syncedVaultsFolder);
      for (const vault of vaults) {
        if (vault.name === this.settings.vaultName || vault.name === this.app.vault.getName()) {
          continue;
        }
        new import_obsidian.Notice(`Syncing vault: ${vault.name}`);
        const vaultFolder = `${syncedVaultsFolder}/${vault.name}`;
        await this.ensureDirectory(vaultFolder);
        const filesResponse = await fetch(`${this.settings.serverUrl}/sync/pull`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${this.settings.token}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            vaultName: vault.name,
            lastSync: null
            // Get all files
          })
        });
        if (!filesResponse.ok) {
          new import_obsidian.Notice(`Failed to sync vault: ${vault.name}`);
          continue;
        }
        const data = await filesResponse.json();
        const serverFiles = data.files;
        for (const serverFile of serverFiles) {
          if (!serverFile.deleted && serverFile.content) {
            const targetPath = `${vaultFolder}/${serverFile.path}`;
            const dir = targetPath.substring(0, targetPath.lastIndexOf("/"));
            if (dir) {
              await this.ensureDirectory(dir);
            }
            const existingFile = this.app.vault.getAbstractFileByPath(targetPath);
            if (existingFile instanceof import_obsidian.TFile) {
              await this.app.vault.modify(existingFile, serverFile.content);
            } else {
              await this.app.vault.create(targetPath, serverFile.content);
            }
          }
        }
      }
      new import_obsidian.Notice("All vaults synced successfully!");
    } catch (error) {
      console.error("Sync all vaults error:", error);
      new import_obsidian.Notice("Failed to sync all vaults: " + error.message);
    }
  }
  async fetchAllVaults() {
    if (!this.settings.token) {
      new import_obsidian.Notice("Please login first");
      return;
    }
    try {
      const response = await fetch(`${this.settings.serverUrl}/vaults`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.settings.token}`
        }
      });
      if (!response.ok) {
        throw new Error("Failed to fetch vault list");
      }
      const vaults = await response.json();
      return vaults;
    } catch (error) {
      console.error("Fetch vaults error:", error);
      new import_obsidian.Notice("Failed to fetch vaults: " + error.message);
      return [];
    }
  }
};
var SyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Custom Sync Settings" });
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("URL of your sync server").addText((text) => text.setPlaceholder("https://example.com/sync").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
      this.plugin.settings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    if (!this.plugin.settings.token) {
      containerEl.createEl("h3", { text: "Authentication" });
      let username = "";
      let password = "";
      new import_obsidian.Setting(containerEl).setName("Username").addText((text) => text.setPlaceholder("Enter username").onChange((value) => {
        username = value;
      }));
      new import_obsidian.Setting(containerEl).setName("Password").addText((text) => {
        text.inputEl.type = "password";
        text.setPlaceholder("Enter password").onChange((value) => {
          password = value;
        });
      });
      new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Login").onClick(async () => {
        if (await this.plugin.login(username, password)) {
          this.display();
        }
      })).addButton((button) => button.setButtonText("Register").onClick(async () => {
        if (await this.plugin.registerUser(username, password)) {
          this.display();
        }
      }));
    } else {
      new import_obsidian.Setting(containerEl).setName("Logged in as").setDesc(this.plugin.settings.username).addButton((button) => button.setButtonText("Logout").onClick(async () => {
        this.plugin.settings.token = "";
        this.plugin.settings.username = "";
        await this.plugin.saveSettings();
        this.display();
      }));
      new import_obsidian.Setting(containerEl).setName("Vault name").setDesc("Name of this vault on the server").addText((text) => text.setPlaceholder(this.app.vault.getName()).setValue(this.plugin.settings.vaultName).onChange(async (value) => {
        this.plugin.settings.vaultName = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Auto-sync interval").setDesc("Minutes between automatic syncs (0 to disable)").addText((text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.syncInterval)).onChange(async (value) => {
        const interval = parseInt(value) || 0;
        this.plugin.settings.syncInterval = interval;
        await this.plugin.saveSettings();
        if (interval > 0) {
          this.plugin.startAutoSync();
        } else if (this.plugin.syncInterval) {
          window.clearInterval(this.plugin.syncInterval);
        }
      }));
      if (this.plugin.settings.lastSync) {
        new import_obsidian.Setting(containerEl).setName("Last sync").setDesc(new Date(this.plugin.settings.lastSync).toLocaleString());
      }
      new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Sync Now").onClick(async () => {
        await this.plugin.syncVault();
      }));
      containerEl.createEl("h3", { text: "All Vaults" });
      new import_obsidian.Setting(containerEl).setName("Sync all vaults").setDesc("Pull changes from all your vaults on the server").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncAllVaults).onChange(async (value) => {
        this.plugin.settings.syncAllVaults = value;
        await this.plugin.saveSettings();
      }));
      if (this.plugin.settings.knownVaults.length > 0) {
        new import_obsidian.Setting(containerEl).setName("Known vaults").setDesc(this.plugin.settings.knownVaults.join(", "));
      }
      new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Fetch All Vaults").onClick(async () => {
        const vaults = await this.plugin.fetchAllVaults();
        if (vaults && vaults.length > 0) {
          new import_obsidian.Notice(`Found ${vaults.length} vaults: ${vaults.map((v) => v.name).join(", ")}`);
          this.display();
        }
      })).addButton((button) => button.setButtonText("Sync All Vaults").onClick(async () => {
        await this.plugin.syncAllVaults();
      }));
    }
  }
};
